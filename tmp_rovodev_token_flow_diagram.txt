TOKEN VALIDATION FLOW - COMPLETE TRACE
==========================================

Step 1: USER CLICKS "CONNECT TO CHATBOT" IN FLOSSLY
---------------------------------------------------
Location: Flossly CRM (https://dev.flossly.ai or your Flossly instance)
Action: Generates JWT token with 60-second expiry
Token Payload:
  - userId: 69
  - orgId: 299
  - roleId: 1
  - purpose: "third_party_redirect"
  - iat: 1770401499 (issued at)
  - exp: 1770401559 (expires 60 seconds later)

Redirects to: https://builder.flossly.ai/botbuilder/auth?token=<JWT_TOKEN>


Step 2: BROWSER LOADS BOT BUILDER FRONTEND
-------------------------------------------
Location: src/components/AuthWrapper.jsx (line 26-88)
Action: useEffect hook runs the authenticateUser() function

Code Flow:
  Line 29: const shortToken = searchParams.get('token');
           → Extracts token from URL query parameter
  
  Line 32-36: if (shortToken && shortToken.trim() !== '') {
               → Checks if token exists and is not empty
               → Calls: authService.exchangeShortToken(shortToken)


Step 3: TOKEN EXCHANGE API CALL
--------------------------------
Location: src/services/authService.js (line 15-47)
Action: exchangeShortToken() sends the JWT to backend for validation

API Call Details:
  URL: https://dev.flossly.ai/api/auth/exchangeShortToken
       (via proxy in development: localhost:3001/api/auth/exchangeShortToken)
  
  Method: POST
  Headers:
    - Content-Type: application/json
    - Accept: application/json
  
  Body: { "shortToken": "<JWT_TOKEN>" }

⚠️ THIS IS WHERE THE VALIDATION HAPPENS ⚠️
The JWT token is sent to the FLOSSLY BACKEND API
NOT validated in your frontend code!


Step 4: BACKEND VALIDATES THE TOKEN
------------------------------------
Location: FLOSSLY BACKEND (https://dev.flossly.ai)
         NOT in your vps-deployment/server.js
         This is the MAIN Flossly API server

Backend Logic (on Flossly side):
  1. Receives the JWT token
  2. Verifies JWT signature using secret key
  3. Checks token expiration (exp field)
     → exp: 1770401559 (Feb 6, 2026 18:12:39 UTC)
     → Current time when you tried: 18:15:00 UTC
     → Token is EXPIRED by 3 minutes!
  4. Returns error response


Step 5: ERROR RESPONSE HANDLING
--------------------------------
Location: src/services/authService.js (line 29-39)

Response from backend (when token is expired):
  {
    "success": false,
    "code": <error_code>,
    "message": "Token expired" or similar error
  }

Code Flow:
  Line 31: if (data.success && data.code === 0) {
           → This condition FAILS because token is expired
  
  Line 35-38: return { 
                success: false, 
                error: data.message || 'Token exchange failed' 
              };


Step 6: UNAUTHORIZED STATE
---------------------------
Location: src/components/AuthWrapper.jsx (line 38-42)

Code Flow:
  Line 38: if (!tokenResult.success) {
           → Detects failed token exchange
  
  Line 39: setError(tokenResult.error || 'Token exchange failed');
           → Sets error message
  
  Line 40: setAuthState('unauthorized');
           → Changes state to 'unauthorized'
  
  Line 120-122: Shows <Unauthorized /> component


SUMMARY
=======
✅ Frontend receives token from URL
✅ Frontend sends token to Flossly backend API
❌ FLOSSLY BACKEND validates and REJECTS expired token
❌ Frontend shows "Unauthorized" page

The token checking happens on the FLOSSLY BACKEND at:
https://dev.flossly.ai/api/auth/exchangeShortToken

Your frontend code does NOT validate the token.
It only sends it to the backend and handles the response.

THE PROBLEM:
------------
Token expires in 60 seconds, but by the time the user:
1. Clicks button (0 seconds)
2. Redirect happens (1-2 seconds)
3. Page loads (1-2 seconds)
4. React app initializes (1-2 seconds)
5. API call is made (1-2 seconds)

Total time: 4-8 seconds (or more with slow connections)

In your case, the token was already 3 minutes old when you tried to use it,
meaning you either:
- Copied the URL and tried to reuse it later
- Had a significant delay in the redirect process
- The token was generated too early before the redirect
